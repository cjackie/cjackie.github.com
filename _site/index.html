<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Chaojie's Blog &middot; starry night
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <img src="/images/profile.png">
    <p>Writings inspired from daily life.</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item active" href="/">Home</a>

    

    
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/about/">About</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="/archive/">All posts</a>
        
      
    
      
    
      
        
      
    
    
    <a class="sidebar-nav-item" href="https://github.com/cjackie">GitHub</a>
    <a class="sidebar-nav-item" href="https://www.linkedin.com/pub/chaojie-wang/6b/a7a/290">Linkedin</a>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2014. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Chaojie's Blog</a>
            <small>starry night</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2014/07/17/email/">
        Email
      </a>
    </h1>

    <span class="post-date">17 Jul 2014</span>
    
    <h4>I just wanna send a freaking email</h4>

<p>Today at work, we tried to make a alarm for our arduino system. It&#39;s going to be text message or email. Ironically, arduino with gsm connect from T-mobile won&#39;t be able to send the message! So, we had to found another way.</br>
We knew how to make a http connection through arduino gsm shield. So, we are going to take that as the base to send some kind of &quot;alarm&quot;. Here are some proposals we had:
- find a vendor that will provide restful API to send email or text message
- connect email directly from arduino.</p>

<p>As a result, we spent a lot of time looking for a good vendor.. Good means free vendor. LMAO. It turned out they all need monthly fee, which is very cheap. After exploring their APIs, which obviously has not arduino support. So we had to found out how http request API works underneath the hood, which I&#39;m very glad we did. In this process, we, at least I, learned alot about http protocol and how it works.</p>

<h4>How http works.</h4>

<p>Have worked with http for a long time, sometimes I just forgot that It&#39;s just a protocol(an agreement between server and client how they communicate). Many website offers API for different programming languages to make http request, but at the end, they all become plain text(later zeros and ones) and get send over to the other. If you keep this in mind, You will know that, as long as you can get a text sent over network, you will be able to request info from other websites. Wow, this is powerful, you don&#39;t need abstractions provided by modules/library of different languages. </br>
Now, let&#39;s talk about how http works. We are all familliar with http in browsers - You enter a web url, and hit enter, and wola there is a beautiful webpage. What&#39;s going on is http is being sent over the network. There are two type of http request, one is POST, the other is GET. HTTP contains lots of headers to describe what kind of request is. For example Content-Type specifies what kind of content the request body has. It would be json, html and so on. Headers are important, and they are often hidden away from developers when they use a module or library for http. As a result, when you write an application on top of HTTP using those modules/libraries, things will work and feel like magic, but at the end it&#39;s just a http being past back and forth. I&#39;m glad I can make this observation.</p>

<h4>Another way, send an email directly from arduino</h4>

<p>At the end, we are able to send a text message using third party&#39;s RESTful API (In fact this is very easy to implement on their part, because mobile carriers have specified a way to send text by sending an email to a specific location). However it wasn&#39;t free. And, my partner has found a way to send the email directly from telnet without any authenication. wow!!! what! yes, you heard it right. that actually surprised me. Then I try it with telnet, then i was able to send a freaking email to myself. I specified It was sent from my own address without any authenication. But, the email was labeled &quot;might not be sent from the user&quot;. Okay, That makes sense. otherwise how broken is the email system! However it doesn&#39;t display that message on the mobile, which is concerning. After digging more info about email, I sort of got how the email system worked. they are sent using SMTP protocol. And using telnet, you can connect to google email server and instruct it to send an email. What&#39;s more, I learned that telnet uses port 25. And many protocol like ssh, whois protocol and alot of more unheard protocols have their own specified ports. wow, That means I can use it to connect to different ports and use different functionalities of a server. That&#39;s awesome!</br>
Back to the arduino, we didn&#39;t make it make on arduino.. We think it might have something to do with that the fact that we uses gsm and the google mail server will deny the access. But I think it&#39;s worth it. Because I learned a lot in the process.</p>

<h4>Ending</h4>

<p>...... good luck tomorrow.</p>

  </div>
  <hr>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2014/07/09/www/">
        How html, css and js work in browsers
      </a>
    </h1>

    <span class="post-date">09 Jul 2014</span>
    
    <h3>Introduction</h3>

<p>We often take things for granted, and web is one of them. Lots of things going on behind the scene when you open up a website. Once you understand what&#39;s going on underneath the hook, you will be able to optimize your website, and make the best out of browsers.</p>

<h3>Brief History</h3>

<p>At the beginning of Internet, Browsers were implemented to process a protocol called HTTP. Back then, web pages were all static, which means once you load the content, it won&#39;t change. Then Javascript came around, which makes it possible to change elements on the page dynamically. Javascript wasn&#39;t taken seriously until the book called JavaScript: The Good Parts in 2008. Later we saw a huge progress in web is made in last few years. Websites became more interactive, more dynamic, and more complex. </p>

<h3>How websites work in browsers</h3>

<p>Here I&#39;m going to make a over-simplified version of what&#39;s going on. Although different browsers works different, but they all follow more or less same blue-print. First, when you open up the url, a HTTP request will be sent. A remote Server will receive the request, process it and then return a HTTP response. The response can contain any data. The browser will parse the response and determine what it is. Let&#39;s say it&#39;s a html. The browser will be start to parse the html into DOM tree. In this process, if it might send out more HTTP request to get javascripts, css, images and so on. Some request will block the contructing process, for example, css and javascript if you don&#39;t make it async or defer. Upon getting css files, the browser will contructing CSSOM , another tree-like constructure. Taken the DOM and CSSOM, the browser will start to render the page. Since there is javacript, which can modify DOM and CSSOM, page might be rendered over time. which makes it dynamic.</p>

<h3>Some usefully strategies to minimize latency of websites</h3>

<ul>
<li>Minimize data being transfer over to clients. for example compress css, js and html.</li>
<li>Don&#39;t block contructing DOM process. for example, make js asyn. make less HTTP request.</li>
</ul>

  </div>
  <hr>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2014/07/05/mindset/">
        一些感想
      </a>
    </h1>

    <span class="post-date">05 Jul 2014</span>
    
    <p>前几天，我在hacker news上看到一个人的<a href="https://medium.com/@maebert/9-things-i-learned-as-a-software-engineer-c2c9f76c9266">博客</a>，我感觉挺值得分享的。在他那个博客里，主要说了自己在做程序员那段时间里所学到的9点东西。在那9样中，我感觉第一项与第八项目最为重要了。<br>
第一项，他说，Intelligence is overrated。中文来说就是，一个人的智商其实没那么重要。我非常的同意这一点。一个人如果很聪明，他考试可以考的很好，学起来可以十分的轻松。对于脑袋不是很灵活的人，可能他学的比较吃力，学不好。不过，后者很可能会比前者学到很多更重要的东西：努力，坚持不懈，等等。在社会中，后者也更容易适应下来。对于学习一帆风顺的人，一旦面对困难就很容易退缩下来。然而，在社会里，困难挫折这多不能免掉的。相对于聪明，努力与坚持不懈的品格的人更容易成功（事业上）。<br>
第八项，自己看吧。我总是做不到的一项。不过我会努力去做到的。</p>

  </div>
  <hr>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2014/07/01/handleAsyncCode/">
        Ways to handle asynchronous code in Javascript
      </a>
    </h1>

    <span class="post-date">01 Jul 2014</span>
    
    <p>Yesterday, I came across function generators in Javascript, which is very similar to Python&#39;s function generator. The function generator is characterized by the keyword <code>yield</code>, which will suspend the function when it&#39;s called with <code>next()</code>. That&#39;s my simple understanding of function generator. I think it&#39;s trying to mimic lazy evaluation in languages like Haskell, and this makes infinite data structure easy to be expressed. <br>
Anyway, I found function generator was because I found <a href="https://github.com/koajs/koa">koa</a> is using this new feature from Ecmascript 6 to construct async codes in a sync way. I didn&#39;t understand how koa can achieve it using <code>yield</code> at first (even though I understand function generator). But after I searched more info about it, I started to understand it. From what I understand, koa take all generator functions and call them behind the scene until no more yield. I think it&#39;s very neat solution to avoid callback hell and makes asynchronous code more readable if you want to make them execute in a synchronous way. Many solutions have been invented by very smart people in Javascript community, noticeably using promise. libraries like <a href="https://github.com/kriskowal/q">Q</a> has been able to solve the same problem quite well. This is quite popular, I saw it many times. However, comparing function generator and promise, I think function generator is better to solve sync problems.<br>
Reason 1: function generator is light weight and it&#39;s implemented in native code, as suppose to library. So I will assume it has better performance.<br>
Reason 2: control flow using function generator looks more imperative.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js">//using co library
co(function* () {
  var text = yield readFile();
  var webpage = yield get('google.com');
  console.log(text);
  console.log(webpage);
})();

//above is not valid code, just use to illustrate concept.
</code></pre></div>
<p>whereas, you use promise it will look something like:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js">//using library Q
Q.fcall(readFile)
.then(function (text) {
  console.log(text);
  return get('google.com');
}).then(....) 

//above is not valid code, just use to illustrate the concept
</code></pre></div>
<p>if a person who is not familiar with callback, he or she will be likely to understand first one. indeed, I think the first looks more natural. you just think of it execute step by step. yield will pause the function until async function is finished. Promise approach tries to use <code>then</code> sugar to make it appear more natural, but you still need to think about callback(maybe I&#39;m wrong). Anyway, yield appears more natural.</p>

<hr>

<p>haha, ecmascript 6 is comming up. lots of new things will be added to the language, like <code>let</code>, <code>for of</code>, some standard <code>collections</code> and more. Let&#39;s see how it&#39;s gonna be. looking forward to it. :smile:</p>

  </div>
  <hr>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2014/06/25/AOP_in_javacript/">
        Aspect-Oriented Programming in Javascript
      </a>
    </h1>

    <span class="post-date">25 Jun 2014</span>
    
    <h2>Aspect-Oriented Programming</h2>

<p>It might sound complicated, but the idea is in fact very simple, which is adding new behavior to a function. This can be done using in object-oriented way, but for some problems, AOP is a better solution. Let&#39;s say you would like to print something before the call, and print something after that call for debugging purposes. Of course you can just make a subclass and add those functionality. However, it feels very unnatural. With AOP, it&#39;s straight forward: add one behavior before the call and another one after the call. The abstraction really free you from thinking details about class relationships, and other methods, and make you focus more on what the code does.<br>
  Let&#39;s give an example of AOP:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">function Person(name) { 
  this.name = name
}

Person.prototype.say = funciton() {
  console.log(this.name);
}
</code></pre></div>
<p>Now you make an &#39;instance&#39; of it (in reality, better call it create a new an object)</p>
<div class="highlight"><pre><code class="language-js" data-lang="js">var jack = new Person('jack');
</code></pre></div>
<p>Then you change you mind and say, &quot;you know what, let&#39;s say &#39;hello everyone&#39; before say the name&quot;. You just want to change the <code>say</code> function, nothing else.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js">var say = jack.say;
jack.say = function() {
  console.log('hello everyone');
  say.call(jack);
};
</code></pre></div>
<p>Thanks to closure, it works. That&#39;s it, 4 lines of codes. Now, whenever jack call <code>say</code> function, it will print out &#39;hello everyone&#39;, before whatever old method say does. Wow, this is neat. <br>
Let&#39;s break it down here. <code>var say = jack.say;</code> this is used to save the reference to original <code>say</code> function. then we redefine the <code>say</code> function for jack, <code>jack.say = function() {...};</code>. Inside the function, we will say hello to every, <code>console.log(&#39;hello everyone&#39;);</code>, then call the original function <code>say.call(jack);</code>. <code>say.call(jack);</code> is the way to invoke the old function, you might wonder why don&#39;t we just invoke the function like <code>say()</code>. This is because that <code>say</code> has different context, when it should be within the <code>jack</code> context. so we need to reinforce the context by using the method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call">call</a></p>

  </div>
  <hr>
  
</div>

<div class="pagination">
  
    <span class="pagination-item older">Older</span>
  
  
    <span class="pagination-item newer">Newer</span>
  
</div>


      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
